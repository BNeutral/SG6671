<!doctype html>
<html>

<head>
<title>SG6671 - TP1</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="lib/gl-matrix.js"></script>
<script type="text/javascript" src="lib/webgl-utils.js"></script>
<script type="text/javascript" src="src/herencia.js"></script>
<script type="text/javascript" src="src/glSetup.js"></script>
<script type="text/javascript" src="src/malla.js"></script>
<script type="text/javascript" src="src/textura.js"></script>
<script type="text/javascript" src="src/objeto.js"></script>
<script type="text/javascript" src="src/camara.js"></script>
<script type="text/javascript" src="src/camaraPrimeraPersona.js"></script>
<script type="text/javascript" src="src/camaraOrbital.js"></script>
<script type="text/javascript" src="src/grilla.js"></script>
<script type="text/javascript" src="src/piso.js"></script>
<script type="text/javascript" src="src/cubo.js"></script>
<script type="text/javascript" src="src/ejes.js"></script>
<script type="text/javascript" src="src/escena.js"></script>
<script type="text/javascript" src="src/objUtil.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec3 vLightWeighting;

    uniform sampler2D uSampler;

    void main(void) 
    {
        vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uViewMatrix;
    uniform mat4 uModelMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;


    ///////////////////////////////////////////////////////////////////////////////////////////
    //
    // Variables uniformes involucradas en la iluminación de la escena
    // 
    // uAmbientColor - representa una intensidad de luz constante que
    // ilumina a todos los objetos sin provenir de una dirección o fuente de luz determinada
    // Es un nivel de intensidad de luz omni-presente
    //
    // uLightPosition - Representa la posición en coordenadas de la escena o mundo donde
    // donde se ubica una luz puntual. Este tipo de luz irradia en todas direcciones.
    // Las superficies (triángulos) cuya normal apunte a esta posición será las que recibirán
    // la máxima intensidad y por lo tanto serán las más iluminadas.
    // A medida que la normal se aparte de esta dirección la intensidad disminuye y en caso que se
    // ubique de manera ortogonal la intensidad será nula
    //
    // uDirectionalColor - Representa el color de la luz puntual
    //
    // uUseLighting - Variable booleana que activa / descativa el cálculo de la iluminación
    uniform vec3 uAmbientColor;
    uniform vec3 uLightPosition;
    uniform vec3 uDirectionalColor;
    uniform bool uUseLighting;
    //
    ////////////////////////////////////////////////////////////////////////////////////////////
    
    varying vec2 vTextureCoord;
    varying vec3 vLightWeighting;

    void main(void) 
    {
	
            // Transformamos al vértice al espacio de la cámara
            vec4 pos_camera_view = uViewMatrix * uModelMatrix * vec4(aVertexPosition, 1.0);
            // Transformamos al vértice al espacio de la proyección
            gl_Position = uPMatrix * pos_camera_view;
            // Coordenada de textura sin modifiaciones
            vTextureCoord = aTextureCoord;

            ////////////////////////////////////////////
            // Calculos de la iluminación
            vec3 light_dir_normalized =  normalize(uLightPosition - vec3( pos_camera_view ) );
            if (!uUseLighting) 
            {
                vLightWeighting = vec3(1.0, 1.0, 1.0);
            }
            else 
            {
                vec3 transformedNormal = normalize(uNMatrix * aVertexNormal);
                float directionalLightWeighting = max(dot(transformedNormal, light_dir_normalized), 0.0);
                vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
            }
		////////////////////////////////////////////
    }
</script>

<script type="text/javascript">

    var gl;
    var shaderProgram;
    var escena;    
    var renderizarLineas = 0;  // Si se debe renderear como lineas en vez de superficies
    
    
    var mouseDown = false;
    var lastMouseX = null;
    var lastMouseY = null;
    
    
    var pitch = 0;
    var pitchRate = 0;

    var yaw = 0;
    var yawRate = 0;
    var joggingAngle = 0;
    var speed = 0;    
    
    var xPos = 0;
    var yPos = 0.5;
    var zPos = 0;

    var deltaX=0.1;

    var deltaY=0.1;
  
  
    function handleMouseDown(event) {
      mouseDown = true;
      lastMouseX = event.clientX;
      lastMouseY = event.clientY;
    }

    function handleMouseUp(event) {
      mouseDown = false;
    }

    function handleMouseMove(event) {
      if (!mouseDown) {
	return;
      }
      var newX = event.clientX;
      var newY = event.clientY;

      deltaX = newX - lastMouseX;
      deltaY = newY - lastMouseY;

    }
  
    var currentlyPressedKeys = {};
    
    function handleKeyDown(event) {
        currentlyPressedKeys[event.keyCode] = true;
    }


    function handleKeyUp(event) {
        currentlyPressedKeys[event.keyCode] = false;
    }

    
    var lastTime = 0;
    
    function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;

            if (speed != 0) {
                xPos -= Math.sin(degToRad(yaw)) * speed * elapsed;
                zPos -= Math.cos(degToRad(yaw)) * speed * elapsed;

                joggingAngle += elapsed * 0.6;
                yPos = Math.sin(degToRad(joggingAngle)) / 20 + 0.4;
            }

            yaw += yawRate * elapsed;
            pitch += pitchRate * elapsed;

        }
        lastTime = timeNow;
    }

    function handleKeys() {

        if (currentlyPressedKeys[33]) {
            // Page Up
            pitchRate = 0.1;
        } else if (currentlyPressedKeys[34]) {
            // Page Down
            pitchRate = -0.1;
        } else {
            pitchRate = 0;
        }
 
        if (currentlyPressedKeys[37] || currentlyPressedKeys[65]) {
            // Left cursor key or A
            yawRate = 0.1;
        } else if (currentlyPressedKeys[39] || currentlyPressedKeys[68]) {
            // Right cursor key or D
            yawRate = -0.1;
        } else {
            yawRate = 0;
        }

        if (currentlyPressedKeys[38] || currentlyPressedKeys[87]) {
            // Up cursor key or W
            speed = 0.003;
        } else if (currentlyPressedKeys[40] || currentlyPressedKeys[83]) {
            // Down cursor key
            speed = -0.003;
        } else {
           speed = 0;
        }
        
        if (currentlyPressedKeys[69] ) {
            // Letra e, cambiar camara
            escena.cambiarCamara();
            console.log("apretada la e");
        } 

        // Aprete ESC para renderear como lineas
        if (currentlyPressedKeys[27]) renderizarLineas = 1;
        else renderizarLineas = 0;
    }
    
    function update() 
    {
        requestAnimFrame(update);
        handleKeys();
        animate();
        escena.setVariables(pitch,yaw,xPos,yPos,zPos,deltaX,deltaY);
        escena.update();
        escena.dibujar();
        
	lastMouseX = newX
	lastMouseY = newY;
    }


    function agregarObjetos() 
    {
        //escena.agregarObjeto(new Objeto(null, null));
        //escena.agregarObjeto(new Grilla(10,10,[1.0,1.0,1.0,1.0],"texturas/debug.jpg",1.0,1.0));
        escena.agregarObjeto(new Ejes());
        var cubo = new Cubo("texturas/debug.jpg");
        mat4.translate(cubo.matrices, cubo.matrices, [2,1,0]);
        escena.agregarObjeto(cubo);
        escena.agregarObjeto(new Piso());
    }
    
    function webGLStart()
    {
        var canvas = document.getElementById("TP1-SistemasGraficos");
        initGL(canvas);
        initShaders();
        
        var camaraPrimera = new CamaraPrimeraPersona(canvas.width, canvas.height);
        var camaraOrbital = new CamaraOrbital(canvas.width, canvas.height);

        escena = new Escena(camaraPrimera);
        escena.agregarCamara(camaraOrbital);
        agregarObjetos();
        
        document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;
        
        canvas.onmousedown = handleMouseDown;
	document.onmouseup = handleMouseUp;
	document.onmousemove = handleMouseMove;
        
        gl.clearColor(0.8, 0.8, 1.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

	update();
    }

</script>

</head>

<body onload="webGLStart();">
    <center>
        <h1>Sistemas Gráficos - TP1</h1>
        <canvas id="TP1-SistemasGraficos" style="border: none;" width="1280" height="720">
        Your browser does not support the HTML5 canvas element.
        </canvas>
    </center>
</body>
</html>